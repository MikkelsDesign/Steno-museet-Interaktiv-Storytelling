<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Zigzag Curtain Dodge Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      color: white;
      font-family: sans-serif;
    }
    #startBtn {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 10px 20px;
      font-size: 16px;
      z-index: 10;
    }
    #scoreDisplay {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <button id="startBtn">Start Game</button>
  <div id="scoreDisplay">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const radialTelegraphs = [];
    const lineTelegraphs = [];


    let width = window.innerWidth;
    let height = window.innerHeight;
    let spiralRotation = 0;
    let spiralActive = false;
    let spiralStartTime = 0;
    let spiralDuration = 3000;

    canvas.width = width;
    canvas.height = height;

    const arena = {
      x: width / 4,
      y: height / 4,
      width: width / 2,
      height: height / 2
    };

    const player = {
      x: arena.x + arena.width / 2,
      y: arena.y + arena.height / 2,
      radius: 10,
      vx: 0,
      vy: 0,
      speed: 0.2,
      maxSpeed: 2,
      friction: 0.95
    };

    const keys = {};
    document.addEventListener('keydown', e => keys[e.key] = true);
    document.addEventListener('keyup', e => keys[e.key] = false);

    const bullets = [];
    let startTime = null;
    let lastScoreTick = null;
    let running = false;
    let score = 0;

    let attackIndex = 0;
    const attacks = [
      { time: 2000, action: spawnSpiralFlowerBursts },
      { time: 6000, action: spawnSpinningSpiralAttack },
      { time: 11000, action: spawnZigzagCurtain }
    ];

function spawnZigzagCurtain() {
  const gapHeight = 120;
  const blockSize = 20;
  const rows = Math.floor(arena.height / blockSize);
  let gapY = Math.floor(Math.random() * (rows - gapHeight / blockSize - 2)) * blockSize + blockSize;
  let zigzagDirection = 1;

  for (let col = 0; col < 80; col++) {
    for (let i = 0; i < rows; i++) {
      const y = arena.y + i * blockSize;
      if (y < arena.y + gapY || y > arena.y + gapY + gapHeight) {
        bullets.push({
          x: arena.x + arena.width + col * blockSize,
          y: y,
          width: blockSize - 2,
          height: blockSize - 2,
          vx: -2.5,
          vy: 0,
          hasHitPlayer: false
        });
      }
    }
    if (Math.random() < 0.5) {
      gapY += zigzagDirection * blockSize;
    }
    if (gapY <= blockSize || gapY >= arena.height - gapHeight - blockSize) {
      zigzagDirection *= -1;
    }
  }
}


function spawnSpiralFlowerBursts() {
  const bursts = 4;
  for (let i = 0; i < bursts; i++) {
    const delay = i * 470;
    const centerX = arena.x + Math.random() * arena.width;
    const centerY = arena.y + Math.random() * arena.height;

    // Add a telegraph that lasts just before the burst
    radialTelegraphs.push({
      x: centerX,
      y: centerY,
      radius: 40,
      startTime: performance.now() + delay,
      duration: 800
    });

    setTimeout(() => {
      const num = 24;
      const speed = 2;
      for (let j = 0; j < num; j++) {
        const angle = (j / num) * 2 * Math.PI;
        bullets.push({
          x: centerX,
          y: centerY,
          width: 16,
          height: 16,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          hasHitPlayer: false
        });
      }
    }, delay + 800);
  }
}




function spawnSpinningSpiralAttack() {
  const centerX = arena.x + arena.width / 2;
  const centerY = arena.y + arena.height / 2;

  const duration = 4000;
  const segments = 60;
  const directions = 10;
  const speed = 1.8;
  const telegraphDelay = 800;

  // Telegraph in center
  radialTelegraphs.push({
    x: centerX,
    y: centerY,
    radius: 100,
    startTime: performance.now(),
    duration: telegraphDelay
  });

  for (let i = 0; i < segments; i++) {
    const delay = telegraphDelay + (i / segments) * duration;
    const baseAngle = (i / segments) * Math.PI; // 180° arc over 4s

    setTimeout(() => {
      for (let d = 0; d < directions; d++) {
        const angle = baseAngle + (d * (2 * Math.PI / directions));
        bullets.push({
          x: centerX,
          y: centerY,
          width: 16,
          height: 16,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          hasHitPlayer: false,
          born: performance.now(),
          ttl: 6000
        });
      }
    }, delay);
  }
}






    function updatePlayer() {
      if (keys['ArrowUp']) player.vy -= player.speed;
      if (keys['ArrowDown']) player.vy += player.speed;
      if (keys['ArrowLeft']) player.vx -= player.speed;
      if (keys['ArrowRight']) player.vx += player.speed;

      // Apply friction
      player.vx *= player.friction;
      player.vy *= player.friction;

      // Clamp speed
      player.vx = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, player.vx));
      player.vy = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, player.vy));

      player.x += player.vx;
      player.y += player.vy;

      // Bound inside arena
      player.x = Math.max(arena.x + player.radius, Math.min(arena.x + arena.width - player.radius, player.x));
      player.y = Math.max(arena.y + player.radius, Math.min(arena.y + arena.height - player.radius, player.y));
    }

   function updateBullets() {
  const now = performance.now();
  for (let i = bullets.length - 1; i >= 0; i--) {
    let b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;

    if (b.ttl && now - b.born > b.ttl) {
      bullets.splice(i, 1); // Remove expired bullet
    }
  }
}

    function drawArena() {
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.strokeRect(arena.x, arena.y, arena.width, arena.height);
    }

    function drawPlayer() {
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fill();
    }

  function drawBullets() {
  ctx.fillStyle = 'white';
  for (let bullet of bullets) {
    ctx.save();
    ctx.translate(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2);
    ctx.rotate((bullet.angle || 0) * Math.PI / 180);
    ctx.fillRect(-bullet.width / 2, -bullet.height / 2, bullet.width, bullet.height);
    ctx.restore();
  }
}

function drawRadialTelegraphs(currentTime) {
  for (let t of radialTelegraphs) {
    const elapsed = currentTime - t.startTime;
    if (elapsed >= 0 && elapsed <= t.duration) {
      const pulse = (Math.sin((elapsed / t.duration) * Math.PI * 4) + 1) / 2; // oscillates 0–1
      const opacity = 0.3 + 0.4 * pulse;

      const gradient = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, t.radius);
      gradient.addColorStop(0, `rgba(255, 0, 0, ${opacity})`);
      gradient.addColorStop(1, `rgba(255, 0, 0, 0)`);

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

function drawLineTelegraphs(currentTime) {
  ctx.save();
  for (let t of lineTelegraphs) {
    const elapsed = currentTime - t.startTime;
    if (elapsed >= 0 && elapsed <= t.duration) {
      const pulse = (Math.sin((elapsed / t.duration) * Math.PI * 4) + 1) / 2;
      const opacity = 0.3 + 0.4 * pulse;
      ctx.translate(t.x, t.y);
      ctx.rotate((t.angle || 0) * Math.PI / 180);
      ctx.fillStyle = `rgba(255, 0, 0, ${opacity})`;
      ctx.fillRect(-t.width / 2, -t.height / 2, t.width, t.height);
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
    }
  }
  ctx.restore();
}



   function checkCollisions() {
  for (let bullet of bullets) {
    if (bullet.hasHitPlayer) continue;

    let dx = Math.abs(player.x - (bullet.x + bullet.width / 2));
    let dy = Math.abs(player.y - (bullet.y + bullet.height / 2));
    if (dx < player.radius + bullet.width / 2 && dy < player.radius + bullet.height / 2) {
      bullet.hasHitPlayer = true;
      score -= 3;
      console.log("HIT!");
    }
  }
}

    function runAttackSequence(currentTime) {
      while (attackIndex < attacks.length && currentTime - startTime >= attacks[attackIndex].time) {
        attacks[attackIndex].action();
        attackIndex++;
      }
    }

    function updateScore(currentTime) {
      if (currentTime - lastScoreTick >= 1000) {
        score += 5;
        lastScoreTick = currentTime;
      }
      scoreDisplay.textContent = `Score: ${score}`;
    }

function loop() {
  if (!running) return;
  const currentTime = performance.now();

  ctx.clearRect(0, 0, width, height);

  updatePlayer();
  updateBullets();
  checkCollisions();
  runAttackSequence(currentTime);
  updateScore(currentTime);

  drawRadialTelegraphs(currentTime);
  drawLineTelegraphs(currentTime);
  drawArena();
  drawPlayer();
  drawBullets();

  requestAnimationFrame(loop);
}

// ✅ THEN call it from button
startBtn.onclick = () => {
  if (!running) {
    startTime = performance.now();
    lastScoreTick = startTime;
    running = true;
    startBtn.style.display = "none";
    loop(); // now works
  }
};

  </script>
</body>
</html>
